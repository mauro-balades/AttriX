import { parse as parseHTML, type HTMLElement } from "node-html-parser";
import { parse as parseCSSValue } from "postcss-values-parser";
import { readFile } from "fs/promises";

type AttributeType =
  | "color"
  | "size"
  | "number"
  | "boolean"
  | "never"
  | "possition"
  | "string"
  | "url"
  | "word";
interface ICSSAttribute {
  type: "var" | "property";
  valueType: AttributeType[] | AttributeType;
  CSSName?: string;
  CSSValue: string;
  subAttributes?: Record<string, AttributeType | AttributeType[]>;
  canHaveShortHand?: boolean;
  allowedValues?: string[];
}
interface ICSSSubAttribute {
  types: AttributeType | AttributeType[];
  parentAttribute: {
    name: string;
    attr: ICSSAttribute;
  };
}

const createCssValue = (name: string) => `--attrix-${name}`;
const createComposedCssAttribute = (
  name: string,
  subAttributes: Record<string, AttributeType | AttributeType[]>,
  cssName?: string,
  canHaveShortHand = false,
): Record<string, ICSSAttribute> => {
  if (!cssName) {
    cssName = name;
  }
  if (canHaveShortHand) {
    subAttributes = {
      shorthand: [...Object.values(subAttributes)].flat(),
      ...subAttributes,
    };
  }
  return {
    [name]: {
      type: "property",
      valueType: "never",
      CSSName: cssName,
      CSSValue: Object.entries(subAttributes)
        .map(
          ([subKey, _]) => "var(" + createCssValue(`${name}-${subKey}`) + ")",
        )
        .join(" "),
      subAttributes,
      canHaveShortHand,
    },
  };
};

const CSSDefinitions: Record<string, ICSSAttribute> = {
  color: {
    type: "property",
    valueType: "color",
    CSSValue: "<value>",
  },
  ...createComposedCssAttribute(
    "bg",
    {
      color: "color",
      image: "string",
      size: "size",
      position: "possition",
    },
    "background",
    true,
  ),
  grid: {
    type: "property",
    valueType: "never",
    CSSName: "display",
    CSSValue: "grid",
  },
  flex: {
    type: "property",
    valueType: "never",
    CSSName: "display",
    CSSValue: "flex",
  },
  column: {
    type: "property",
    valueType: "never",
    CSSName: "flex-direction",
    CSSValue: "column",
  },
  row: {
    type: "property",
    valueType: "never",
    CSSName: "flex-direction",
    CSSValue: "row",
  },
  justify: {
    type: "property",
    valueType: "word",
    allowedValues: ["start", "end", "center", "between", "around", "evenly"],
    CSSName: "justify-content",
    CSSValue: "<value>",
  },
};

const gGatheredAttrs: { key: string; value: string }[] = [];
const gParentAttributesToFill = new Map<string, ICSSAttribute>();
const gMediaQueriesToFill = new Map<string, string>();

const gTagsToIgnore = new Set(["head", "script", "style"]);
const gMediaQueries = new Set(["sm", "md", "lg", "xl", "2xl", "print", "dark"]);

const gStyleSheetHeader = `/* Generated by AttriX Gatherer */\n\n`;

const getMediaQuery = (name: string): string => {
  switch (name) {
    case "sm":
      return "@media (min-width: 640px)";
    case "md":
      return "@media (min-width: 768px)";
    case "lg":
      return "@media (min-width: 1024px)";
    case "xl":
      return "@media (min-width: 1280px)";
    case "2xl":
      return "@media (min-width: 1536px)";
    case "print":
      return "@media print";
    case "dark":
      return "@media (prefers-color-scheme: dark)";
    default:
      throw new Error(`Unknown media query: ${name}`);
  }
};

const findCSSAttribute = (
  name: string,
): ICSSAttribute | ICSSSubAttribute | undefined => {
  if (CSSDefinitions[name]) {
    return CSSDefinitions[name];
  }
  // It may be a composed attribute
  for (const key in CSSDefinitions) {
    const attr = CSSDefinitions[key];
    // Remove the prefix if it exists, the prefix is the parent attribute
    if (!name.startsWith(`${key}-`)) {
      continue;
    }
    const subAttrName = name.slice(key.length + 1);
    if (attr.subAttributes && attr.subAttributes[subAttrName]) {
      return {
        types: attr.subAttributes[subAttrName],
        parentAttribute: {
          name: key,
          attr: attr,
        },
      };
    }
  }
  return undefined;
};
const getSanitizedCSSSelector = (
  name: string | string[],
  value: string,
): string => {
  if (Array.isArray(name) && !!value) {
    throw new Error(
      `The value for a selector with multiple names should be empty, got: ${value}`,
    );
  }
  return !Array.isArray(name)
    ? `[${name}="${value.replace(/"/g, '\\"')}"]`
        .replace(/[\s\n]+/g, " ")
        .trim()
    : ":is(" + name.map((n) => `[${n}]`).join(", ") + ")";
};

const getCSSRule = (
  name: string | string[],
  selectorValue: string,
  value: string,
  cssname?: string,
): string => {
  const sanitizedSelector = getSanitizedCSSSelector(name, selectorValue);
  if (!cssname) {
    cssname = name[0];
  }
  return `${sanitizedSelector} { ${cssname}: ${value}; }\n`;
};

const isAttributeASubAttribute = (
  attr: ICSSAttribute | ICSSSubAttribute,
): attr is ICSSSubAttribute => {
  return (
    (attr as ICSSSubAttribute).types !== undefined &&
    (attr as ICSSSubAttribute).parentAttribute !== undefined
  );
};

const validateCSSValue = (
  value: string,
  type: AttributeType | AttributeType[],
  attr: ICSSAttribute,
): string => {
  if (!Array.isArray(type)) {
    type = [type];
  }
  let errorCount = 0;
  const checkIfCSSValue = (
    expected: string,
    value: string,
    cssValueType: string,
  ) => {
    const parsedValue = parseCSSValue(value).nodes[0];
    if (parsedValue.type !== cssValueType) {
      errorCount++;
    }
  };
  const checkIfCSSListOfWords = (value: string, list: string[]) => {
    let found = false;
    for (const word of list) {
      if (value.includes(word)) {
        found = true;
        break;
      }
    }
    if (!found) {
      errorCount++;
    }
  };
  let foundType = "";
  for (const t of type) {
    const prevErrorCount = errorCount;
    switch (t) {
      case "color":
        checkIfCSSValue("color", value, "word");
        break;
      case "size":
        checkIfCSSListOfWords(value, [
          "small",
          "medium",
          "large",
          "x-large",
          "xx-large",
        ]);
        break;
      case "number":
        checkIfCSSValue("number", value, "number");
        break;
      case "boolean":
        if (value !== "true" && value !== "false") {
          errorCount++;
        }
        break;
      case "never":
        if (value !== "") {
          errorCount++;
        }
        break;
      case "possition":
        checkIfCSSListOfWords(value, [
          "top",
          "bottom",
          "left",
          "right",
          "center",
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
        ]);
        break;
      case "string":
        if (value.trim() === "") {
          errorCount++;
        }
        // No specific validation for string, just ensure it's not empty
        break;
      case "url":
        if (!/^https?:\/\/[^\s]+$/.test(value)) {
          errorCount++;
        }
        // No specific validation for URL, just ensure it starts with http:// or https://
        break;
      case "word":
        if (value.trim() === "") {
          errorCount++;
          break;
        }
        let foundWord = false;
        for (const word of attr.allowedValues || []) {
          if (value.includes(word)) {
            foundWord = true;
            break;
          }
        }
        if (!foundWord) {
          errorCount++;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${t}`);
    }
    if (errorCount === prevErrorCount) {
      // If the error count didn't change, it means the type matched
      foundType = t;
      break;
    }
  }
  // If the error count is less, that means at least one of the types matched
  if (errorCount >= type.length) {
    throw new Error(
      `Invalid value "${value}" for attribute type(s): ${type.join(", ")}`,
    );
  }
  return foundType;
};

const createStyleSheet = () => {
  let sheet = gStyleSheetHeader;
  for (const attr of gGatheredAttrs) {
    let { key, value } = attr;
    let foundMediaQuery = "";
    let foundMendiaQueryName = "";
    for (const mediaQuery of gMediaQueries) {
      if (key.startsWith(`${mediaQuery}:`)) {
        // It's a media query, we need to handle it separately
        key = key.slice(mediaQuery.length + 1); // Remove the media query prefix
        foundMediaQuery = getMediaQuery(mediaQuery) as string;
        foundMendiaQueryName = mediaQuery;
        break;
      }
    }
    const getCSSAttributeName = (name: string) => {
      if (foundMediaQuery) {
        return `${foundMendiaQueryName}:${name}`;
      }
      return name;
    };
    const addToStyleSheet = (rule: string) => {
      if (foundMediaQuery) {
        if (!gMediaQueriesToFill.has(foundMediaQuery)) {
          gMediaQueriesToFill.set(foundMediaQuery, "");
        }
        gMediaQueriesToFill.set(
          foundMediaQuery,
          gMediaQueriesToFill.get(foundMediaQuery) + "\t" + rule,
        );
      } else {
        sheet += rule;
      }
    };
    const cssAttr = findCSSAttribute(key);
    if (cssAttr) {
      if (isAttributeASubAttribute(cssAttr)) {
        // It's a composed attribute, we need to create a parent attribute
        const parentAttr = cssAttr.parentAttribute;
        if (!gParentAttributesToFill.has(parentAttr.name)) {
          gParentAttributesToFill.set(parentAttr.name, parentAttr.attr);
        }
        // Add to the style sheet as the form of a CSS variable
        const varName = createCssValue(`${parentAttr.name}-${key}`);
        validateCSSValue(value, cssAttr.types, parentAttr.attr);
        addToStyleSheet(getCSSRule(getCSSAttributeName(key), value, value, varName));
      } else {
        // It's a simple attribute
        if (cssAttr.type === "property") {
          if (cssAttr.subAttributes) {
            if (!gParentAttributesToFill.has(cssAttr.CSSName || key)) {
              gParentAttributesToFill.set(getCSSAttributeName(key), cssAttr);
            }
          }
          // Add to the style sheet as the form of a CSS variable
          if (cssAttr.canHaveShortHand && cssAttr.subAttributes) {
            const typeFound = validateCSSValue(
              value,
              cssAttr.subAttributes?.shorthand || cssAttr.valueType,
              cssAttr,
            );
            const subAttributeWithType = Object.entries(
              cssAttr.subAttributes || {},
            ).find(([subKey, subType]) => subType === typeFound);
            if (!subAttributeWithType) {
              throw new Error(
                `No sub-attribute found for ${key} with value type ${cssAttr.valueType}`,
              );
            }
            const varName = createCssValue(
              `${cssAttr.CSSName || key}-${subAttributeWithType[0]}`,
            );
            addToStyleSheet(getCSSRule(getCSSAttributeName(key), value, value, varName));
          } else {
            validateCSSValue(value, cssAttr.valueType, cssAttr);
            addToStyleSheet(
              getCSSRule(getCSSAttributeName(key), value, value, cssAttr.CSSName || key),
            );
          }
        } else {
          throw new Error(
            `Unsupported attribute type: ${cssAttr.type} for attribute ${key}`,
          );
        }
      }
    }
  }
  for (const [name, attr] of gParentAttributesToFill) {
    // Add the parent attributes to the style sheet
    const attributeNames = Object.keys(attr.subAttributes || {})
      .filter((subKey) => subKey !== "shorthand")
      .map((sub) => `${name}-${sub}`);
    attributeNames.push(name);
    const cssValue = attr.CSSValue;
    sheet += getCSSRule(attributeNames, "", cssValue, attr.CSSName || name);
  }
  for (const query of gMediaQueries) {
    if (gMediaQueriesToFill.has(getMediaQuery(query))) {
      const rules = gMediaQueriesToFill.get(getMediaQuery(query));
      sheet += `${getMediaQuery(query)} {\n${rules}}\n`;
    }
  }
  return sheet;
};

const transformHtml = (html: HTMLElement) => {
  // Recursively gather attributes
  const gatherAttributes = (node: HTMLElement) => {
    if (gTagsToIgnore.has(node.rawTagName)) {
      return;
    }
    if (node.attributes) {
      Object.entries(node.attributes).forEach(([key, value]) => {
        // Check if the attribute is already gathered
        if (
          !gGatheredAttrs.some(
            (attr) => attr.key === key && attr.value === value,
          )
        ) {
          gGatheredAttrs.push({ key, value });
        }
        for (const child of node.childNodes) {
          if (child) {
            gatherAttributes(child as HTMLElement);
          }
        }
      });
    }
    node.childNodes.forEach(gatherAttributes as any);
  };
  gatherAttributes(html);
  // Create a CSS style sheet from the gathered attributes
  const styleSheet = createStyleSheet();
  return styleSheet;
};

const transformString = (str: string) => {
  const root = parseHTML(str);
  return transformHtml(root);
};

const main = async (args: string[]) => {
  const file = args[0];
  if (!file) {
    console.error("Usage: node index.js <file>");
    process.exit(1);
  }
  const content = await readFile(file, "utf-8");
  const transformed = transformString(content);
  console.log(transformed);
};

if (require.main === module) {
  main(process.argv.slice(2))
    .then(() => process.exit(0))
    .catch((err) => {
      console.error(err);
      process.exit(1);
    });
}
