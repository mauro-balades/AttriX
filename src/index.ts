import { parse as parseHTML, type HTMLElement } from "node-html-parser";
import { parse as parseCSSValue } from "postcss-values-parser";
import { readFile } from "fs/promises";

type AttributeType =
  | "color"
  | "size"
  | "number"
  | "boolean"
  | "never"
  | "possition"
  | "string"
  | "url"
  | "word";

interface ICSSAttribute {
  type: "var" | "property";
  valueType: AttributeType[] | AttributeType;
  CSSName?: string;
  CSSValue: string;
  allowedValues?: string[];
}

const createCssValue = (name: string) => `--attrix-${name}`;

const CSSDefinitions: Record<string, ICSSAttribute> = {
  color: {
    type: "property",
    valueType: "color",
    CSSValue: "<value>",
  },
  grid: {
    type: "property",
    valueType: "never",
    CSSName: "display",
    CSSValue: "grid",
  },
  flex: {
    type: "property",
    valueType: "never",
    CSSName: "display",
    CSSValue: "flex",
  },
  column: {
    type: "property",
    valueType: "never",
    CSSName: "flex-direction",
    CSSValue: "column",
  },
  row: {
    type: "property",
    valueType: "never",
    CSSName: "flex-direction",
    CSSValue: "row",
  },
  justify: {
    type: "property",
    valueType: "word",
    allowedValues: ["start", "end", "center", "between", "around", "evenly"],
    CSSName: "justify-content",
    CSSValue: "<value>",
  },
  bgcolor: {
    type: "property",
    valueType: "color",
    CSSName: "background-color",
    CSSValue: "<value>",
  },
  padding: {
    type: "property",
    valueType: "size",
    CSSName: "padding",
    CSSValue: "<value>",
  },
};

const gGatheredAttrs: { key: string; value: string }[] = [];
const gMediaQueriesToFill = new Map<string, string>();
const gReusableComponents = new Map<string, typeof gGatheredAttrs>();

const gTagsToIgnore = new Set(["head", "script", "style"]);
const gMediaQueries = new Set(["sm", "md", "lg", "xl", "2xl", "print", "dark"]);

const gStyleSheetHeader = `/* Generated by AttriX Gatherer */\n\n`;

const getMediaQuery = (name: string): string => {
  switch (name) {
    case "sm":
      return "@media (min-width: 640px)";
    case "md":
      return "@media (min-width: 768px)";
    case "lg":
      return "@media (min-width: 1024px)";
    case "xl":
      return "@media (min-width: 1280px)";
    case "2xl":
      return "@media (min-width: 1536px)";
    case "print":
      return "@media print";
    case "dark":
      return "@media (prefers-color-scheme: dark)";
    default:
      throw new Error(`Unknown media query: ${name}`);
  }
};

const findCSSAttribute = (name: string): ICSSAttribute | undefined => {
  return CSSDefinitions[name];
};
const getSanitizedCSSSelector = (
  name: string | string[],
  value: string,
): string => {
  if (Array.isArray(name) && !!value) {
    throw new Error(
      `The value for a selector with multiple names should be empty, got: ${value}`,
    );
  }
  return !Array.isArray(name)
    ? `[${name}="${value.replace(/"/g, '\\"')}"]`
        .replace(/[\s\n]+/g, " ")
        .trim()
    : ":is(" + name.map((n) => `[${n}]`).join(", ") + ")";
};

const getCSSRule = (
  name: string | string[],
  selectorValue: string,
  value: string,
  cssname?: string,
): { selector: string; value: string } => {
  const sanitizedSelector = getSanitizedCSSSelector(name, selectorValue);
  if (!cssname) {
    cssname = name[0];
  }
  return {
    selector: sanitizedSelector,
    value: `${cssname}: ${value};`,
  };
};

const validateCSSValue = (
  value: string,
  type: AttributeType | AttributeType[],
  attr: ICSSAttribute,
): string => {
  if (!Array.isArray(type)) {
    type = [type];
  }
  let errorCount = 0;
  const checkIfCSSValue = (
    expected: string,
    value: string,
    cssValueType: string,
  ) => {
    const parsedValue = parseCSSValue(value).nodes[0];
    if (parsedValue.type !== cssValueType) {
      errorCount++;
    }
  };
  const checkIfCSSListOfWords = (value: string, list: string[]) => {
    let found = false;
    for (const word of list) {
      if (value.includes(word)) {
        found = true;
        break;
      }
    }
    if (!found) {
      errorCount++;
    }
  };
  let foundType = "";
  for (const t of type) {
    const prevErrorCount = errorCount;
    switch (t) {
      case "color":
        checkIfCSSValue("color", value, "word");
        break;
      case "size":
        checkIfCSSListOfWords(value, [
          "small",
          "medium",
          "large",
          "x-large",
          "xx-large",
        ]);
        break;
      case "number":
        checkIfCSSValue("number", value, "number");
        break;
      case "boolean":
        if (value !== "true" && value !== "false") {
          errorCount++;
        }
        break;
      case "never":
        if (value !== "") {
          errorCount++;
        }
        break;
      case "possition":
        checkIfCSSListOfWords(value, [
          "top",
          "bottom",
          "left",
          "right",
          "center",
          "top-left",
          "top-right",
          "bottom-left",
          "bottom-right",
        ]);
        break;
      case "string":
        if (value.trim() === "") {
          errorCount++;
        }
        // No specific validation for string, just ensure it's not empty
        break;
      case "url":
        if (!/^https?:\/\/[^\s]+$/.test(value)) {
          errorCount++;
        }
        // No specific validation for URL, just ensure it starts with http:// or https://
        break;
      case "word":
        if (value.trim() === "") {
          errorCount++;
          break;
        }
        let foundWord = false;
        for (const word of attr.allowedValues || []) {
          if (value.includes(word)) {
            foundWord = true;
            break;
          }
        }
        if (!foundWord) {
          errorCount++;
        }
        break;
      default:
        throw new Error(`Unknown attribute type: ${t}`);
    }
    if (errorCount === prevErrorCount) {
      // If the error count didn't change, it means the type matched
      foundType = t;
      break;
    }
  }
  // If the error count is less, that means at least one of the types matched
  if (errorCount >= type.length) {
    throw new Error(
      `Invalid value "${value}" for attribute type(s): ${type.join(", ")}`,
    );
  }
  return foundType;
};

const createStyleSheet = () => {
  let attrsSheet = "";
  let componentsSheet = "";
  let attributeCSSValues = new Map<string, string>();
  for (const attr of gGatheredAttrs) {
    let { key, value } = attr;
    let foundMediaQuery = "";
    let foundMendiaQueryName = "";
    for (const mediaQuery of gMediaQueries) {
      if (key.startsWith(`${mediaQuery}:`)) {
        // It's a media query, we need to handle it separately
        key = key.slice(mediaQuery.length + 1); // Remove the media query prefix
        foundMediaQuery = getMediaQuery(mediaQuery) as string;
        foundMendiaQueryName = mediaQuery;
        break;
      }
    }
    const getCSSAttributeName = (name: string) => {
      if (foundMediaQuery) {
        return `${foundMendiaQueryName}:${name}`;
      }
      return name;
    };
    const addToStyleSheet = ({
      selector,
      value,
    }: {
      selector: string;
      value: string;
    }) => {
      const rule = `${selector} { ${value} }\n`;
      if (foundMediaQuery) {
        if (!gMediaQueriesToFill.has(foundMediaQuery)) {
          gMediaQueriesToFill.set(foundMediaQuery, "");
        }
        gMediaQueriesToFill.set(
          foundMediaQuery,
          gMediaQueriesToFill.get(foundMediaQuery) + "\t" + rule,
        );
      } else {
        attrsSheet += rule;
      }
      if (!attributeCSSValues.has(key)) {
        attributeCSSValues.set(key, value);
      }
    };
    const cssAttr = findCSSAttribute(key);
    if (cssAttr) {
      if (cssAttr.type === "property") {
        // Add to the style sheet as the form of a CSS variable
        validateCSSValue(value, cssAttr.valueType, cssAttr);
        addToStyleSheet(
          getCSSRule(
            getCSSAttributeName(key),
            value,
            value,
            cssAttr.CSSName || key,
          ),
        );
      } else {
        throw new Error(
          `Unsupported attribute type: ${cssAttr.type} for attribute ${key}`,
        );
      }
    }
  }
  for (const component of gReusableComponents) {
    const [componentName, attributes] = component;
    let componentSheet = `${componentName} {\n`;
    for (const attr of attributes) {
      const valFromCSS = attributeCSSValues.get(attr.key);
      if (!valFromCSS) {
        throw new Error(
          `bug: Attribute ${attr.key} not found in CSS values for component ${componentName}`,
        );
      }
      componentSheet += `\t${valFromCSS}\n`;
    }
    componentSheet += `}\n`;
    componentsSheet += componentSheet;
  }
  for (const query of gMediaQueries) {
    if (gMediaQueriesToFill.has(getMediaQuery(query))) {
      const rules = gMediaQueriesToFill.get(getMediaQuery(query));
      attrsSheet += `${getMediaQuery(query)} {\n${rules}}\n`;
    }
  }
  if (gReusableComponents.size) {
    attrsSheet += `:is(${[...gReusableComponents.keys()]
      .map((name) => `[x:${name}]`)
      .join(", ")}) {\n`;
    attrsSheet += `\tdisplay: none !important;\n`;
    attrsSheet += `}\n`;
  }
  return gStyleSheetHeader + componentsSheet + attrsSheet;
};

const transformHtml = (html: HTMLElement) => {
  // Recursively gather attributes
  const gatherAttributes = (node: HTMLElement) => {
    if (gTagsToIgnore.has(node.rawTagName)) {
      return;
    }
    const elementAttributes: typeof gGatheredAttrs = [];
    if (node.attributes) {
      Object.entries(node.attributes).forEach(([key, value]) => {
        // Check if the attribute is already gathered
        if (
          !gGatheredAttrs.some(
            (attr) => attr.key === key && attr.value === value,
          )
        ) {
          gGatheredAttrs.push({ key, value });
        }
        if (!elementAttributes.some((attr) => attr.key === key)) {
          elementAttributes.push({ key, value });
        }
        for (const child of node.childNodes) {
          if (child) {
            gatherAttributes(child as HTMLElement);
          }
        }
      });
    }
    if (node.rawTagName?.toLowerCase().startsWith("x:")) {
      // We found a reusable component, we need to gather its attributes
      const componentName = node.rawTagName.slice(2);
      if (!gReusableComponents.has(componentName)) {
        gReusableComponents.set(componentName, elementAttributes);
      }
    }
    node.childNodes.forEach(gatherAttributes as any);
  };
  gatherAttributes(html);
  // Create a CSS style sheet from the gathered attributes
  const styleSheet = createStyleSheet();
  return styleSheet;
};

const transformString = (str: string) => {
  const root = parseHTML(str);
  return transformHtml(root);
};

const main = async (args: string[]) => {
  const file = args[0];
  if (!file) {
    console.error("Usage: node index.js <file>");
    process.exit(1);
  }
  const content = await readFile(file, "utf-8");
  const transformed = transformString(content);
  console.log(transformed);
};

if (require.main === module) {
  main(process.argv.slice(2))
    .then(() => process.exit(0))
    .catch((err) => {
      console.error(err);
      process.exit(1);
    });
}
